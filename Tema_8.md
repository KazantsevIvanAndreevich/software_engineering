## Тема 8. Введение в ООП
Отчет по Теме #8 выполнил(а):
- Казанцев Иван Андреевич
- ИНО ЗБ ПОАС 22-2

| Задание | Сам_раб |
| ------ | ------ |
| Задание 1 | + |
| Задание 2 | + |
| Задание 3 | + |
| Задание 4 | + |
| Задание 5 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Person:
    pass  # Ничего не делаем здесь, это пустой класс

# Создаем объект класса Person
john = Person()

# Выводим информацию о объекте
print(john)
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_2/pic/tema2_1.png)

## Выводы
Класс Person определен с помощью ключевого слова pass. Затем мы создаем объект john этого класса и выводим его в консоль.
  
## Самостоятельная работа №2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def greet(self):
        print(f"Привет, меня зовут {self.name} и мне {self.age} лет.")

# Создаем объект класса Person
john = Person("John", 30)

# Вызываем метод greet для объекта john
john.greet()
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_2/pic/tema2_2.png)

## Выводы
У класса Person есть атрибуты name и age, которые инициализируются при создании объекта класса. Метод greet использует значения этих атрибутов для вывода приветствия.
  
## Самостоятельная работа №3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def greet(self):
        print(f"Привет, меня зовут {self.name} и мне {self.age} лет.")

class Employee(Person):
    def __init__(self, name, age, position):
        super().__init__(name, age)
        self.position = position
    
    def introduce(self):
        print(f"Привет, меня зовут {self.name}, мне {self.age} лет, и я работаю на должности {self.position}.")

# Создаем объект класса Employee
alice = Employee("Alice", 25, "менеджер")

# Вызываем метод greet из класса Person
alice.greet()

# Вызываем метод introduce из класса Employee
alice.introduce()
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_2/pic/tema2_3.png)

## Выводы
Этот код создает класс Person, который имеет атрибуты name и age, а также метод greet, который выводит приветствие с именем и возрастом. Затем создается дочерний класс Employee, который наследует функциональность класса Person и добавляет к нему атрибут position и метод introduce, который выводит приветствие с именем, возрастом и должностью сотрудника.
  
## Самостоятельная работа №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
```python
class Person:
    def __init__(self, name, age):
        self._name = name  # Префикс _ указывает на защищенный атрибут
        self._age = age    # Префикс _ указывает на защищенный атрибут
    
    def greet(self):
        print(f"Привет, меня зовут {self._name} и мне {self._age} лет.")

class Employee(Person):
    def __init__(self, name, age, position):
        super().__init__(name, age)
        self._position = position  # Префикс _ указывает на защищенный атрибут
    
    def introduce(self):
        print(f"Привет, меня зовут {self._name}, мне {self._age} лет, и я работаю на должности {self._position}.")

# Создаем объект класса Employee
alice = Employee("Alice", 25, "менеджер")

# Попытка доступа к защищенным атрибутам напрямую вызовет ошибку
print(alice._name)        # Вызовет ошибку
print(alice._age)         # Вызовет ошибку
print(alice._position)    # Вызовет ошибку

# Однако мы можем использовать публичные методы классов для доступа к данным
alice.greet()             # Выведет: Привет, меня зовут Alice и мне 25 лет.
alice.introduce()         # Выведет: Привет, меня зовут Alice, мне 25 лет, и я работаю на должности менеджер.
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_2/pic/tema2_4.png)

## Выводы
В этом примере мы используем защищенные атрибуты, которые начинаются с префикса _, чтобы предотвратить прямой доступ к ним извне класса. Однако, защищенные атрибуты по-прежнему доступны из подклассов и могут быть использованы в публичных методах класса для работы с данными.
  
## Самостоятельная работа №5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
import math

class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return math.pi * self.radius ** 2

# Функция, которая принимает любой объект Shape и вызывает его метод area()
def print_area(shape):
    print("Area:", shape.area())

# Создаем экземпляры классов
rectangle = Rectangle(5, 3)
circle = Circle(4)

# Вызываем функцию print_area() с разными объектами Shape
print_area(rectangle)  # Вывод: Area: 15
print_area(circle)     # Вывод: Area: 50.26548245743669
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_2/pic/tema2_5.png)

## Выводы
Модульность и повторное использование кода: ООП позволяет разбивать программу на небольшие модули, каждый из которых отвечает за определенную функциональность. Это способствует повторному использованию кода и упрощает его сопровождение.

Инкапсуляция: Принцип инкапсуляции позволяет объединять данные и методы работы с ними внутри классов. Это обеспечивает скрытость данных и защищает их от непосредственного доступа извне, что способствует безопасности и предотвращает случайные изменения.

Наследование: Механизм наследования позволяет создавать новые классы на основе существующих. Это способствует повторному использованию кода и уменьшению его дублирования, а также облегчает расширение функциональности программы.

Полиморфизм: Он позволяет объектам разных классов иметь одинаковые имена методов, но выполнять различные действия в зависимости от их типа. Это делает код более гибким и удобным для использования.

В целом, работа с числовыми и строковыми значениями является фундаментальной частью программирования, которая охватывает широкий спектр задач и является неотъемлемой частью создания практически любого программного решения.
