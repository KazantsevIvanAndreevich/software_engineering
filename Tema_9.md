## Тема 9. Концепции и принципы ООП
Отчет по Теме #9 выполнил(а):
- Казанцев Иван Андреевич
- ИНО ЗБ ПОАС 22-2

| Задание | Сам_раб |
| ------ | ------ |
| Задание 1 | + |
| Задание 2 | + |
| Задание 3 | + |
| Задание 4 | + |
| Задание 5 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

### Задание Садовник и помидоры.
Классовая структура:
Есть Помидор со следующими характеристиками:
• Индекс 
• Стадия созревания (стадии: отсутствует, цветение, зеленый, красный) 
Помидор может:
• Расти (переходить на следующую стадию созревания) 
• Предоставлять информацию о своей зрелости 
Есть Куст с помидорами, который: 
• Содержит список томатов, которые на нем растут 
А также может: 
• Расти вместе с томатами 
• Предоставлять информацию о зрелости всех томатов
• Предоставлять урожай
И также есть Садовник, который имеет: 
• Имя 
• Растение, за которым он ухаживает 
Он может: 
• Ухаживать за растением 
• Собирать с него урожай
Класс Tomato:
1) Создайте класс Tomato
2) Создайте статическое свойство states, которое будет содержать все стадии созревания помидора
3) Создайте метод __init__(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state  (принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
4) Создайте метод grow(), который будет переводить томат на следующую стадию созревания
5) Создайте метод is_ripe(), который будет проверять, что томат созрел
Класс TomatoBush:
1) Создайте класс TomatoBush
2) Определите метод __init__(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes
3) Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания
4) Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми.
5) Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая
Класс Gardener:
1) Создайте класс Gardener
2) Создайте метод __init__(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
3) Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым
4) Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
5) Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству
Тесты: 
1) Вызовите справку по садоводству
2) Создайте объекты классов TomatoBush и Gardener
3) Используя объект класса Gardener, поухаживайте за кустом с помидорами
4) Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними
5) Соберите урожай

```python
class Tomato:
    # 2) Статическое свойство со стадиями созревания помидора
    states = {
        'отсутствует': 0,
        'цветение': 1,
        'зеленый': 2,
        'красный': 3
    }
    
    def __init__(self, index):
        # 3) Динамические свойства:
        #    _index - индекс помидора
        #    _state - стадия созревания (принимает первое значение из словаря states)
        self._index = index
        self._state = list(self.states.keys())[0]  # Начальная стадия - "отсутствует"

    def grow(self):
        # 4) Метод для перехода на следующую стадию созревания
        if self._state != list(self.states.keys())[-1]:
            current_index = list(self.states.keys()).index(self._state)
            self._state = list(self.states.keys())[current_index + 1]

    def is_ripe(self):
        # 5) Метод для проверки, что томат созрел
        return self._state == 'красный'


class TomatoBush:
    def __init__(self, num):
        # 2) Динамическое свойство tomatoes - список объектов класса Tomato
        self.tomatoes = [Tomato(index) for index in range(1, num + 1)]

    def grow_all(self):
        # 3) Метод для перевода всех томатов на следующую стадию созревания
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        # 4) Метод для проверки, все ли томаты созрели
        return all([tomato.is_ripe() for tomato in self.tomatoes])

    def give_away_all(self):
        # 5) Метод для сбора урожая
        self.tomatoes = []


class Gardener:
    def __init__(self, name, plant):
        # 2) Динамические свойства:
        #    name - имя садовника (передается параметром, является публичным)
        #    _plant - объект класса TomatoBush
        self.name = name
        self._plant = plant

    def work(self):
        # 3) Метод для ухода за растением
        self._plant.grow_all()

    def harvest(self):
        # 4) Метод для сбора урожая
        if self._plant.all_are_ripe():
            self._plant.give_away_all()
            print("Урожай собран!")
        else:
            print("Пока не все помидоры созрели. Продолжайте ухаживать за растением.")

    @staticmethod
    def knowledge_base():
        # 5) Статический метод для вывода справки по садоводству
        print("Справка по садоводству:")
        print("1. Помидоры проходят через несколько стадий созревания: отсутствует, цветение, зеленый, красный.")
        print("2. Садовник должен следить за ростом и созреванием помидоров.")
        print("3. Собирать урожай можно только после полного созревания всех помидоров на кусте.")

```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_2/pic/tema2_1.png)

## Выводы
В данном пункте создаются все классы, методы и атрибуты, которые необходимо создать по заданию
  
## Самостоятельная работа №1
### Вызовите справку по садоводству
   
```python
Gardener.knowledge_base()
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_2/pic/tema2_2.png)

## Выводы
Справка по садоводству вызвана успешно.
  
## Самостоятельная работа №2
### Создайте объекты классов TomatoBush и Gardener
```python
bush = TomatoBush(5)
gardener = Gardener("Иван", bush)
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_2/pic/tema2_3.png)

## Выводы
Созданы объекты классов TomatoBush и Gardener
  
## Самостоятельная работа №3
### Используя объект класса Gardener, поухаживайте за кустом с помидорами

```python
gardener.work()
print("Стадии созревания помидоров после ухода за ними:")
for tomato in bush.tomatoes:
    print(tomato._state)
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_2/pic/tema2_4.png)

## Выводы
Можно использовать операцию умножения для увеличения длины строки
  
## Самостоятельная работа №4
### Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними

```python
gardener.harvest()
```
### Результат.Результатом работы вашей программы будет листинг кода с подробными комментариями и скриншоты выполенния всех тестов.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_2/pic/tema2_5.png)

## Выводы
Сбор урожая не произошёл. 

## Самостоятельная работа №5
### Соберите урожай

```python
for _ in range(3):
    gardener.work()
gardener.harvest()
```
### Результат.Результатом работы вашей программы будет листинг кода с подробными комментариями и скриншоты выполенния всех тестов.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_2/pic/tema2_5.png)

## Выводы
Урожай собран
  
## Общие выводы по теме
Взаимодействие с числовыми значениями: Нам предоставлено множество инструментов для работы с числами, таких как арифметические операции, операции сравнения и преобразования типов данных. Мы можем использовать их для выполнения различных математических вычислений и анализа данных.

Взаимодействие со строковыми значениями: Строки представляют собой последовательности символов, с которыми можно работать, выполняя операции конкатенации, извлечения подстрок, поиска подстрок и многие другие. Это основные операции, которые позволяют нам обрабатывать и анализировать текстовые данные.

Преобразование данных: Во многих случаях необходимо преобразовывать данные из одного типа в другой. Например, преобразование строки в число или наоборот. Понимание того, как выполнять такие преобразования, является важным навыком для решения различных задач.

Валидация данных: При работе с вводом данных важно учитывать возможные ошибки или некорректные значения. Валидация данных помогает обнаружить и обработать такие ситуации, обеспечивая более стабильную работу программы.

Алгоритмы и структуры данных: Работа с числовыми и строковыми данными часто включает в себя использование различных алгоритмов и структур данных для эффективной обработки и анализа информации.

В целом, работа с числовыми и строковыми значениями является фундаментальной частью программирования, которая охватывает широкий спектр задач и является неотъемлемой частью создания практически любого программного решения.
