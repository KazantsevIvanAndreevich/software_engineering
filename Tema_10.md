## Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил(а):
- Казанцев Иван Андреевич
- ИНО ЗБ ПОАС 22-2

| Задание | Сам_раб |
| ------ | ------ |
| Задание 1 | + |
| Задание 2 | + |
| Задание 3 | + |
| Задание 4 | + |
| Задание 5 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Самостоятельная работа №1
### Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор. 
Подсказка: необходимо использовать модуль time 
Декоратор необходимо использовать для этой функции:  
```python
def fibonacci():
  fib1 = fib2 = 1 
  for i in range(2, 200): 
    fib1, fib2 = fib2, fib1 + fib2 
    print(fib2, end=' ') 

if __name__ == '__main__': 
  fibonacci()
```
Результатом вашей работы будет листинг кода и скриншот консоли, в котором будет выполненная функция Фибоначчи и время выполнения программы. Также на этом примере можете посмотреть, что решение задач через рекурсию не всегда является хорошей идеей. Поскольку решение Фибоначчи для 100 с использованием рекурсии и без динамического программирования решается более десяти секунд, а решение точно такой же задачи, но через цикл for еще и для 200, занимает меньше 1 секунды.

```python
import time

def calculate_execution_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Время выполнения функции {func.__name__}: {execution_time} секунд")
        return result
    return wrapper

@calculate_execution_time
def fibonacci():
    fib1 = fib2 = 1 
    for i in range(2, 200): 
        fib1, fib2 = fib2, fib1 + fib2 
        print(fib2, end=' ') 

if __name__ == '__main__': 
    fibonacci()
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/tema10_1.png)

## Выводы
Декоратор успешно замерил время выполнения функции fibonacci() и вывел результат в консоль. Время выполнения составило 0.0002639293670654297 секунды.

## Самостоятельная работа №2
### Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль “файл пустой”, а если он не пустой, то вывести информацию из файла.

```python
def read_file(file_name):
    try:
        with open(file_name, 'r') as file:
            data = file.read()
            if not data:
                raise Exception("файл пустой")
            else:
                print("Информация из файла:")
                print(data)
    except FileNotFoundError:
        print("Файл не найден")
    except Exception as e:
        print(e)

# Создание пустого файла
with open("empty_file.txt", "w") as file:
    pass

# Создание файла с информацией
with open("data_file.txt", "w") as file:
    file.write("Казанцев Иван Андреевич")

# Попытка чтения пустого файла
print("Попытка чтения пустого файла:")
read_file("empty_file.txt")

# Попытка чтения файла с информацией
print("\nПопытка чтения файла с информацией:")
read_file("data_file.txt")
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/tema10_2.png)

## Выводы
Этот код открывает файл, считывает его содержимое, и если файл пустой, вызывает исключение с сообщением "файл пустой". Если файл не пустой, выводит его содержимое.
  
## Самостоятельная работа №3
### Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка “Неподходящий тип данных. Ожидалось число.”. Реализовать функционал программы необходимо через try/except и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и получившийся вывод в консоль.

```python
def add_two(number):
    try:
        result = 2 + int(number)
        print("Результат сложения: ", result)
    except ValueError:
        print("Неподходящий тип данных. Ожидалось число.")

# Тесты с корректным вводом
print("Тесты с корректным вводом:")
add_two(5)
add_two(10)

# Тесты с некорректным вводом
print("\nТесты с некорректным вводом:")
add_two("abc")
add_two([1, 2, 3])
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/tema10_3.png)

## Выводы
Этот код пытается выполнить сложение 2 и введенного числа, преобразуя его в целое число. Если пользователь вводит что-то другое, кроме числа, возникает исключение ValueError, которое перехватывается, и выводится сообщение об ошибке.
  
## Самостоятельная работа №4
### Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("До выполнения функции")
        result = func(*args, **kwargs)
        print("После выполнения функции")
        return result
    return wrapper

# Функция, которая будет использовать декоратор
@my_decorator
def greet(name):
    print("Привет, {}!".format(name))

# Еще одна функция с использованием декоратора
@my_decorator
def square(x):
    return x * x

# Вызов функций
greet("Вовочка")
print("Результат возведения в квадрат:", square(5))
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/tema10_4.png)

## Выводы
Этот код создает собственный декоратор my_decorator, который выводит сообщения до и после выполнения функций, к которым он применяется. Затем декорируются две функции: greet и square. При вызове этих функций будут выводиться сообщения до и после их выполнения.
  
## Самостоятельная работа №5
### Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.

```python
class MyCustomException(Exception):
    pass

# Функция, которая может вызвать исключение
def divide(a, b):
    if b == 0:
        raise MyCustomException("Деление на ноль недопустимо")
    return a / b

# Первый фрагмент кода, использующий собственное исключение
try:
    result = divide(10, 0)
except MyCustomException as e:
    print("Поймано собственное исключение:", e)

# Второй фрагмент кода, также использующий собственное исключение
try:
    x = int(input("Введите число: "))
    if x < 0:
        raise MyCustomException("Введено отрицательное число")
    else:
        print("Вы ввели положительное число")
except MyCustomException as e:
    print("Поймано собственное исключение:", e)
```
### Результат.
![Меню](https://github.com/KazantsevIvanAndreevich/software_engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_10/pic/tema10_5.png)

## Выводы
Этот код создает собственное исключение MyCustomException, которое наследуется от базового класса Exception. Затем исключение используется в двух фрагментах кода: в функции divide, которая проверяет деление на ноль, и во втором фрагменте кода, который проверяет введенное пользователем число.
При выполнении первого фрагмента кода исключение MyCustomException возникает из-за деления на ноль. Во втором фрагменте кода исключение возникает, если пользователь вводит отрицательное число. В обоих случаях программа ловит исключение и выводит соответствующее сообщение.**
 
## Общие выводы по теме
Общие выводы по теме:

Декораторы позволяют добавлять функциональность к функциям и методам, не изменяя их код напрямую.
Они могут быть использованы для реализации различных паттернов проектирования, таких как декоратор, фабричный метод, адаптер и другие.
Декораторы могут быть применены к функциям, методам классов, статическим методам и даже к классам.
Исключения предоставляют механизм обработки ошибок в Python, что позволяет программисту управлять потоком выполнения программы при возникновении ошибок.
Они могут быть использованы для определения собственных типов исключений, что обеспечивает более точное и информативное сообщение об ошибке.
Правильное использование декораторов и исключений способствует улучшению читаемости, поддерживаемости и надежности кода.
